Index: webapp/graphite/render/functions.py
===================================================================
--- webapp/graphite/render/functions.py	(revision 7036)
+++ webapp/graphite/render/functions.py	(working copy)
@@ -128,6 +128,8 @@
 
 def normalize(seriesLists):
   seriesList = reduce(lambda L1,L2: L1+L2,seriesLists)
+  if len(seriesList) == 0:
+    raise ValueError('empty series list')  
   step = reduce(lcm,[s.step for s in seriesList])
   for s in seriesList:
     s.consolidate( step / s.step )
@@ -487,7 +489,7 @@
 
 
   """
-  if len(divisorSeriesList) != 1:
+  if len(divisorSeriesList) != 1 or len(dividendSeriesList) != 1:
     raise ValueError("divideSeries second argument must reference exactly 1 series")
 
   divisorSeries = divisorSeriesList[0]
Index: webapp/graphite/render/evaluator.py
===================================================================
--- webapp/graphite/render/evaluator.py	(revision 7036)
+++ webapp/graphite/render/evaluator.py	(working copy)
@@ -2,9 +2,9 @@
 import time
 from django.conf import settings
 from graphite.render.grammar import grammar
+from graphite.logger import log
 from graphite.render.datalib import fetchData, TimeSeries
 
-
 def evaluateTarget(requestContext, target):
   tokens = grammar.parseString(target)
   result = evaluateTokens(requestContext, tokens)
@@ -24,9 +24,13 @@
     return fetchData(requestContext, tokens.pathExpression)
 
   elif tokens.call:
-    func = SeriesFunctions[tokens.call.func]
-    args = [evaluateTokens(requestContext, arg) for arg in tokens.call.args]
-    return func(requestContext, *args)
+    try:
+      func = SeriesFunctions[tokens.call.func]
+      args = [evaluateTokens(requestContext, arg) for arg in tokens.call.args]
+      return func(requestContext, *args)
+    except ValueError:
+      log.exception('value error when render') 
+      return []
 
   elif tokens.number:
     if tokens.number.integer:
